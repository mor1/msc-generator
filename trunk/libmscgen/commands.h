/*
    This file is part of Msc-generator.
    Copyright 2008,2009,2010,2011,2012,2013 Zoltan Turanyi
    Distributed under GNU Affero General Public License.

    Msc-generator is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Msc-generator is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Msc-generator.  If not, see <http://www.gnu.org/licenses/>.
*/

/** @file commands.h The declaration of classes for commands, entities, etc.
 * @ingroup libmscgen_files */

#if !defined(COMMANDS_H)
#define COMMANDS_H

#include "arcs.h"

/** The base class for commands.
 * Represents an invisible (not drawing anything), thin line of zero height in itself.
 * Child classes add various functions (new page, new background, etc.)
 * Some child classes also add visible effects, such as entity headings. */
class ArcCommand : public ArcBase
{
public:
    ArcCommand(EArcType t, MscProgress::ECategory c, Msc *msc) : ArcBase(t, c, msc) {};
    bool AddAttribute(const Attribute &) {return false;}
    string Print(int ident=0) const;
    virtual void Layout(Canvas &canvas, AreaList *cover);
    virtual void Draw(Canvas &/*canvas*/, EDrawPassType /*pass*/) {}
};

/** The command for entity definition and manipulation.
 * Any mention of an entity results in a CommandEntity, along with the 'heading' command.
 * Subsequent CommandEntity elements are merged in Msc::PostParseProcess() into one.
 * CommandEntity elements are kept in the ArcLists whenever the status (or style) 
 * of an entity changes and/or when an entity heading needs to be drawn.
 * This class contains a set of EntityApp elements that can be tracked by themselves. */
class CommandEntity : public ArcCommand
{
protected:
    EntityAppList          entities;                 ///<The list of EntityApp this command includes
    bool                   full_heading;             ///<True if created from a 'heading' command (or merged with a heading command)
    PtrList<CommandNote>   tmp_stored_notes;         ///<A set of notes attached to one EntityApp in `entities`.
    std::list<std::string> tmp_stored_note_targets;  ///<The name of the target entity for each note in `tmp_stored_notes` (matched by position in list)
    std::string            target_entity;            ///<Subsequent note commands shall target this entity (present in `entities`)
public:
    const bool internally_defined;                   ///<True if generated by an lcomment.* command: will not merge with other CommandEntities
    CommandEntity(EntityAppHelper *e, Msc *msc, bool in);
    virtual bool CanBeNoted() const {return !internally_defined;}
    virtual void AttachComment(CommandNote *);
    /** Returns true if this command will draw an entity heading for all currently showing entities*/
	bool IsFullHeading() {return full_heading;}
    void TmpStoreNote(CommandNote *);
    void ReinsertTmpStoredNotes(ArcList &list, ArcList::iterator after);
	void MoveMyContentAfter(EntityAppHelper &e); 
    string Print(int ident=0) const;
    void AppendToEntities(const EntityAppList &e);
    void Combine(CommandEntity *ce);
    bool AddAttribute(const Attribute &);
    CommandEntity *ApplyPrefix(const char *prefix);
    static void AttributeNames(Csh &csh);
    static bool AttributeValues(const std::string attr, Csh &csh);
    EntityApp* FindAddEntityDefForEntity(const string &entity, const FileLineColRange &l);
    EEntityStatus GetCombinedStatus(const Entity& entity) const;
    virtual ArcBase* PostParseProcess(Canvas &canvas, bool hide, EIterator &left, EIterator &right,
                                      Numbering &number, Element **note_target);
    virtual void Width(Canvas &canvas, EntityDistanceMap &distances);
    virtual void LayoutCommentsHelper(Canvas &canvas, AreaList *cover, double &l, double &r);
    virtual void Layout(Canvas &canvas, AreaList *cover);

    virtual void ShiftBy(double y);
    virtual double SplitByPageBreak(Canvas &/*canvas*/, double /*netPrevPageSize*/,
                                    double /*pageBreak*/, bool &/*addCommandNewpage*/, 
                                    bool /*addHeading*/, ArcList &/*res*/);
    virtual void PostPosProcess(Canvas &cover);
    virtual void Draw(Canvas &canvas, EDrawPassType pass);
};

/** The object representing the `newpage` command or an automatic page break*/
class CommandNewpage : public ArcCommand
{
    bool           auto_heading_attr; ///<True if we need to generate an automatic heading
    CommandEntity *autoHeading;       ///<The automatically inserted heading that follows, NULL if none
public:
    const bool manual;                ///<True if this was inserted by the user manually via the `newpage` command
    CommandNewpage(Msc *msc, bool m, CommandEntity *ah);
    ~CommandNewpage() {if (autoHeading) delete autoHeading;}
	virtual MscProgress::ECategory GetProgressCategory() const {return MscProgress::NEWPAGE;}
    bool AddAttribute(const Attribute &a);
    static void AttributeNames(Csh &csh);
    static bool AttributeValues(const std::string attr, Csh &csh);

    virtual ArcBase* PostParseProcess(Canvas &canvas, bool hide, EIterator &left, EIterator &right,
                                      Numbering &number, Element **note_target);
    virtual void FinalizeLabels(Canvas &canvas);
    virtual void Width(Canvas &canvas, EntityDistanceMap &distances);
    virtual void Layout(Canvas &canvas, AreaList *cover);
    virtual void ShiftBy(double y);
    virtual void CollectPageBreak(double hSize);
    virtual void PlaceWithMarkers(Canvas &/*cover*/, double /*autoMarker*/);
    virtual void PostPosProcess(Canvas &cover);
    virtual void Draw(Canvas &/*canvas*/, EDrawPassType /*pass*/);
};

/** The object representing the background.* = chart option*/
class CommandNewBackground : public ArcCommand
{
public:
    FillAttr fill; ///<The new fill value for the background

    CommandNewBackground(Msc *msc, FillAttr f) : 
        ArcCommand(MSC_COMMAND_NEWBACKGROUND, MscProgress::TINY_EFFORT, msc), 
        fill(f) {}
    virtual void PostPosProcess(Canvas &cover);
};

/** Represents changes to the numbering levels after popping a context.
 * If the number of levels outside a context is less than inside, then 
 * after popping the context, we shall truncate the list of current numbers
 * and increment the resulting last number, so that after 1.2.2, 
 * the next element is 1.3 and not 1.2. 
 * This object can only be generated by Msc::PopContext(). 
 * It is done, if the outer context has less levels of numbering than the inner.*/
class CommandNumbering : public ArcCommand
{
public:
    /** The type of action we need to do to the current number list*/
    enum EAction {
        SIZE=1,      ///<Change the size of the number list to `length`
        INCREMENT=2, ///<After the change, increment the last number
        DECREMENT=4, ///<After the change, decrement the last number (not used currently)
        
    };
    EAction action; ///<What shall be done by us at PostParseProcess()
    size_t  length; ///<If we change the length of the number list in PostParseProcess(), change it to this long (shall be a trimming, never an extension)

    CommandNumbering(Msc *msc, EAction a, size_t l=0) :
        ArcCommand(MSC_COMMAND_NUMBERING, MscProgress::TINY_EFFORT, msc), 
        action(a), length(l) 
        {if (l) action = EAction(action | SIZE); AddAttributeList(NULL);}
    virtual ArcBase* PostParseProcess(Canvas &canvas, bool hide, EIterator &left, EIterator &right,
                                      Numbering &number, Element **note_target);
};

/** Represents a `mark` command, defining a vertical position marker.*/
class CommandMark : public ArcCommand
{
public:
    const string name;   ///<The name of the marker
    double       offset; ///<Its potential offset from its declared position of yPos (an attribute)
    CommandMark(const char *m, FileLineColRange ml, Msc *msc);
    bool AddAttribute(const Attribute &);
    static void AttributeNames(Csh &csh);
    static bool AttributeValues(const std::string attr, Csh &csh);

    virtual void ShiftBy(double y);
};

/** The object we insert for an empty chart (if so requested)*/
class CommandEmpty : public ArcCommand
{
    Label parsed_label; ///<The text we display (usually "empty chart")
public:
    CommandEmpty(Msc *msc) : 
        ArcCommand(MSC_COMMAND_EMPTY, MscProgress::EMPTY, msc) {}
    virtual void Width(Canvas &canvas, EntityDistanceMap &distances);
    virtual void Layout(Canvas &canvas, AreaList *cover);

    virtual void Draw(Canvas &canvas, EDrawPassType pass);
};

/** A temporary class holding two strings of the input file with their location */
class NamePair
{
public:
    string src;             ///<First string
    string dst;             ///<Second string
    FileLineColRange sline; ///<Location of first string
    FileLineColRange dline; ///<Location of second string
    NamePair(const char *s, const FileLineColRange &sl,
                   const char *d, const FileLineColRange &dl) :
        src(s ? s : ""), dst(d ? d : ""), sline(sl), dline(dl) {}
};

/** Represents the `hspace` command*/
class CommandHSpace : public ArcCommand
{
protected:
    EIterator src;                   ///<First of the two entity in between we add the space
    EIterator dst;                   ///<Second of the two entity in between we add the space
    FileLineColRange sline;          ///<Location of the first entity name in the input file (for error msgs)
    FileLineColRange dline;          ///<Location of the second entity name in the input file (for error msgs)
    StringFormat format;             ///<Text format to apply, when the space to add is caluclated as the width of a text
    std::pair<bool, string> label;   ///<Text, the width of which will be used to add space between the two entities (if a text is used)
    std::pair<bool, double> space;   ///<Number of pixels to add between the entities (if a number was given)
public:
    CommandHSpace(Msc*, const NamePair*);
    virtual bool AddAttribute(const Attribute &);
    static void AttributeNames(Csh &csh);
    static bool AttributeValues(const std::string attr, Csh &csh);
    virtual ArcBase* PostParseProcess(Canvas &canvas, bool hide, EIterator &left, EIterator &right,
                                      Numbering &number, Element **note_target);
    virtual void Width(Canvas &canvas, EntityDistanceMap &distances);
};

/** Represents the `vspace` command*/
class CommandVSpace : public ArcCommand
{
protected:
    StringFormat format;             ///<Text format to apply, when the space to add is caluclated as the height of a text
    std::pair<bool, string> label;   ///<Text, the height of which will be used to add space (if a text is used)
    std::pair<bool, double> space;   ///<Number of pixels to add (if a number was given)
    bool compressable;               ///<If true and compress of the below arcs is on, the vertical space is not added (disappears)                                                           
public:
    CommandVSpace(Msc*);
    virtual bool AddAttribute(const Attribute &);
    static void AttributeNames(Csh &csh);
    static bool AttributeValues(const std::string attr, Csh &csh);
    virtual ArcBase* PostParseProcess(Canvas &canvas, bool hide, EIterator &left, EIterator &right,
                                      Numbering &number, Element **note_target);
    virtual void Layout(Canvas &canvas, AreaList *cover);

};

/** Holds a horizontal position, as specified by the user with a description on how to interpret the position.
 * (Apologies for the name.)
 * Can encode the following language fragments:
 * 1. @<prefix> AT @<entity> [@<offset>]
 * 2. @<prefix> AT @<entity> - @<entity> [@<offset>]
 * 3. @<prefix> AT @<entity> -|--|+|++ [@<offset>]
 *
 * Where @<prefix> can be `center`, `left`, `right` or none.
 * This basically says whether the left or right side or the center of an entity shall be at the
 * location specified after the AT clause.
 */
class ExtVertXPos : public VertXPos
{
public:
    /** This basically says whether the left or right side or the center of an entity shall be at the
     * location specified after the AT clause.*/
    enum ERelativeTo {
        LEFT=0,   ///<The left side of the object shall be at this position 
        CENTER=1, ///<The center of the object shall be at this position 
        RIGHT=2,  ///<The right side of the object shall be at this position 
        NONE=3,   ///<No sides were specified
        BAD_SIDE  ///<Invalid value
    } side;       ///<Says what part of the object shall be at this location.
    FileLineColRange side_line; ///<The location of the input file where the left/right/center clause was specified
    explicit ExtVertXPos(Msc&m) : VertXPos(m), side(NONE) {}
    ExtVertXPos(const char *s, const FileLineColRange &sl, const VertXPos *p);
    ExtVertXPos(const VertXPos *p);
};

/** Represents the `symbol` command.*/
class CommandSymbol : public ArcCommand
{
protected:
    /** Describes what type of a symbol it is */
    enum ESymbolType {
        ARC,       ///<An arc symbol
        RECTANGLE, ///<A rectangle symbol
        ELLIPSIS   ///<An allipsis (three vertical dots)
    };
    static const double     ellipsis_space_ratio; ///<The ratio of the height of the dots and the space between them for ellipsises
    ESymbolType             symbol_type;          ///<What type of symbol this is
    StyleCoW                style;                ///<Visual style of the symbol
    ExtVertXPos             hpos1;                ///<First horizontal position
    ExtVertXPos             hpos2;                ///<Second (optional) horizontal position
    NamePair                vpos;                 ///<The two markers for vertical position
    std::pair<bool, double> xsize;                ///<(optional) X size specified by the user. (used for 'arc' and 'rectangle')
    std::pair<bool, double> ysize;                ///<(optional) Y size specified by the user. (used for 'arc' and 'rectangle')
    EArrowSize              size;                 ///<Size of the dots in the ellipsis (used only for '...')
    mutable Block           outer_edge;           ///<The cpmputed bounding box of the symbol
    void CalculateAreaFromOuterEdge();
public:
    CommandSymbol(Msc*, const char *symbol, const NamePair *enp,
                  const ExtVertXPos *vxpos1, const ExtVertXPos *vxpos2);
    virtual bool CanBeNoted() const {return true;}
    virtual bool AddAttribute(const Attribute &);
    static void AttributeNames(Csh &csh);
    static bool AttributeValues(const std::string attr, Csh &csh);
    virtual ArcBase* PostParseProcess(Canvas &canvas, bool hide, EIterator &left, EIterator &right,
                                      Numbering &number, Element **note_target);
    virtual void Width(Canvas &canvas, EntityDistanceMap &distances);
    virtual void Layout(Canvas &canvas, AreaList *cover);

    virtual void ShiftBy(double y);
    /** We are to be ignored if we are off-line (outer_edge is valid) or we cannot rearrange if in-line */
    virtual double SplitByPageBreak(Canvas &/*canvas*/, double /*netPrevPageSize*/,
                                    double /*pageBreak*/, bool &/*addCommandNewpage*/, 
                                    bool /*addHeading*/, ArcList &/*res*/)
                                       {return outer_edge.y.IsInvalid() ? -2 : -1;}
    virtual void PlaceWithMarkers(Canvas &cover, double autoMarker);
    virtual void Draw(Canvas &canvas, EDrawPassType pass);
};

struct score_t;

/** Represents notes and comments */
class CommandNote : public ArcLabelled
{
public:
    const bool           is_float;         ///<True for a note, false for a comment
protected:
    Element             *target;           ///<The arc the note or comment is made to or on
    string               point_toward;     ///<The name of entity or marker specified after an `at` clause for notes
    FileLineColRange     point_toward_pos; ///<The location of name of the entity or marker in the input file
    std::pair<bool, int> float_dist;       ///<User preferences on note placement: how far it shall be from the target (-1:0:+1)
    int                  float_dir_x;      ///<User preferences on note placement: left or right (-1, 0, +1)
    int                  float_dir_y;      ///<User preferences on note placement: up or down (-1, 0, +1)

    mutable XY           halfsize;         ///<Half of the calculated width and height of a note
    mutable XY           pos_center;       ///<Calculated center of the note
    mutable XY           point_to;         ///<The tip of the arrow for a note

public:
    CommandNote(Msc*, const char *pt=NULL, const FileLineColRange &ptm=FileLineColRange());
    CommandNote(Msc*msc, ESide side);
    ~CommandNote();
    virtual bool CanBeNoted() const {return false;}
    /** Return the target arc of the note or command */
    Element *GetTarget() const {return target;}
    /** Set the target to an appearance of an entity */
    void SetTarget(EntityApp *e) {target = e;}
    /** Invalidate this note or comment. Called by Msc::InvalidateNotesToThisTarget() if its target becomes hidden*/
    void Invalidate() {valid = false;} 
    virtual bool AddAttribute(const Attribute &);
    static void AttributeNames(Csh &csh, bool is_float);
    static bool AttributeValues(const std::string attr, Csh &csh, bool is_float);
    virtual ArcBase* PostParseProcess(Canvas &canvas, bool hide, EIterator &left, EIterator &right,
                                      Numbering &number, Element **note_target);
    virtual void FinalizeLabels(Canvas &canvas);
    virtual void Width(Canvas &canvas, EntityDistanceMap &distances);
    virtual void Layout(Canvas &canvas, AreaList *cover);
    virtual void ShiftBy(double y);
    /** A special shift function - we do not, in general shift, but comments shift with their target (called from Element::ShiftBy())*/
    virtual void ShiftCommentBy(double y);
    virtual double SplitByPageBreak(Canvas &/*canvas*/, double /*netPrevPageSize*/,
                                    double /*pageBreak*/, bool &/*addCommandNewpage*/, 
                                    bool /*addHeading*/, ArcList &/*res*/) {return -2;} //Ignore comments for pagination (moved with their owner)

    /** @name Note placement calculation
     * Note placement algorithm works as follows.
     * We split the canvas around the target arc into 3*8 regions coming from 
     * 3 distances and 8 directions. The regions of the same distance are called
     * region belts and are 2D expanded versions of the target cover. A specific 
     * region is a slice of the region belt.
     * We try to place the note at the best place in each region and then
     * score each reagion and pick the one with the highest score.
     * - a weak default differentiation, so we get upper right notes if no user preference and 
     *   its all the some otherwise (no obstacles anywhere)
     * - regions preferred by the user via attributes are scored much higher
     * - if the note in the region overlaps with a critical part of another arc
     *   (such as a label or an arrowhead), we downscore it very badly. Overlaps
     *   to less critical areas are also penalized, but not so heavily
     * - if the pointer arrives to the target arc at a funny angle, we also penalize.
     *
     * @{ */
protected:
    /** Calculate the width of a pointer for a note*/
    double pointer_width(double distance) const;
    /** Returns the contour of the pointer of a note*/
    Contour cover_pointer(const XY &point_to, const XY &center) const; 
    /** The outline of the note calculated from `halfsize`*/
    Contour CoverBody(const XY &center) const; 
    /** The outline of the pointer calculated from `halfsize`. Disjoint from the body.*/
    Contour CoverPointer(const XY &pointto, const XY &center) const 
        {return cover_pointer(pointto, center) - CoverBody(center);}
    /** The combined cover of the body and the pointer calculated from `halfsize`.*/
    Contour CoverAll(const XY &pointto, const XY &center) const 
        {return cover_pointer(pointto, center) + CoverBody(center);}
    static Contour GetRegionMask(const Block &outer, const XY &center, int dir_x, int dir_y);
    std::vector<std::pair<XY, XY>> GetPointerTarget() const;
    void CoverPenalty(const XY &pointto, const XY &center,
                      const Contour &block_all, const Contour &block_imp,
                      score_t &cover_penalty) const;
    void SlantPenalty(const XY &pointto, const XY &center, const XY &tangent, 
                      score_t &slant_penalty) const;
    static bool GetAPointInside(const Contour &c, const XY &p1, const XY &p2, XY&ret);
    static bool GetAPointInside(const DoubleMap<bool> &map, double &ret);
public:
    void PlaceFloating(Canvas &canvas);
    void PlaceSideTo(Canvas &canvas, AreaList *cover, double &y);
    //@}

    //virtual void PostPosProcess(Canvas &cover, double autoMarker);
    virtual void Draw(Canvas &canvas, EDrawPassType pass);
};

/** An arc holding a list of arcs for internal use.*/
class CommandArcList : public ArcCommand
{
protected:
    ArcList content; ///<The list of arcs we represent
public:
    explicit CommandArcList(Msc *m) : 
        ArcCommand(MSC_ARC_ARCLIST, MscProgress::TINY_EFFORT, m), content(true) {}
    CommandArcList(Msc *m, ArcBase *p) :  
        ArcCommand(MSC_ARC_ARCLIST, MscProgress::TINY_EFFORT, m), content(true) {Append(p);}
    CommandArcList(Msc *m, ArcList *l) :  
        ArcCommand(MSC_ARC_ARCLIST, MscProgress::TINY_EFFORT, m), content(true) {Append(l);}

    /** Append a new arc */
    void Append(ArcBase *p) {content.Append(p);}
    /** Move a complete list to us */
    void Append(ArcList *l) {content.splice(content.end(), *l);}
    /** Move our arc to another ArcList */
    void MoveContent(ArcList &list, ArcList::iterator after) {list.splice(++after, content);}
    virtual double SplitByPageBreak(Canvas &/*canvas*/, double /*netPrevPageSize*/,
                                    double /*pageBreak*/, bool &/*addCommandNewpage*/, 
                                    bool /*addHeading*/, ArcList &/*res*/)
                                             {_ASSERT(0); return -1;}
};

class CommandEndNoteSeparator : public ArcCommand
{
public: 
    explicit CommandEndNoteSeparator(Msc *m) :
        ArcCommand(MSC_ARC_EN_SEPARATOR,  MscProgress::TINY_EFFORT, m) {}
    virtual void Layout(Canvas &canvas, AreaList *cover);
    virtual void PostPosProcess(Canvas &cover);
    virtual void Draw(Canvas &canvas, EDrawPassType pass);
};

#endif //COMMANDS_H