/*
    This file is part of Msc-generator.
    Copyright 2008,2009,2010,2011,2012,2013 Zoltan Turanyi
    Distributed under GNU Affero General Public License.

    Msc-generator is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Msc-generator is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Msc-generator.  If not, see <http://www.gnu.org/licenses/>.
*/

/*Parts of this file is based on WildMagic 5.4, which uses the Boost licence,
  which requires me to repeat it here. See http://www.geometrictools.com

	Boost Software License - Version 1.0 - August 17th, 2003

	Permission is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:

	The copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.
*/
 
/** @file contour_ellipse.cpp Defines EllipseData and
 * non-inline functions from contour_basics.h.
 * @ingroup contour_files
 */

#include <cassert>
#include <vector>
#include <algorithm>
#include "contour_edge.h"

namespace contour {


/** Calculates how the line `A`->`B` crosses the rectangle.
 *
 * If no crossing, an invalid range is returned.
 * If there is a crossing, "pos" values are returned, as follows.
 * `0` corresponds to `A`, `1` corresponds to `B`, values in between
 * correspond to the section `A`->`B` and outside likewise.
 */
Range Block::Cut(const XY &A, const XY &B) const
{
    Range ret;
    bool have_one = false;
    if (IsInvalid() || A.test_equal(B)) goto invalid;
    if (test_equal(A.x, B.x)) {
        if (!x.IsWithinBool(A.x)) goto invalid;
        ret.from = (y.from-A.y)/(B.y-A.y);
        ret.till = (y.till-A.y)/(B.y-A.y);
        goto valid;
    }
    if (test_equal(A.y, B.y)) {
        if (!y.IsWithinBool(A.y)) goto invalid;
        ret.from = (x.from-A.x)/(B.x-A.x);
        ret.till = (x.till-A.x)/(B.x-A.x);
        goto valid;
    }
    if (y.IsWithinBool((B.y-A.y)/(B.x-A.x)*(x.from-A.x)+A.y)) {
        ret.from = (x.from-A.x)/(B.x-A.x);
        have_one = true;
    }
    if (y.IsWithinBool((B.y-A.y)/(B.x-A.x)*(x.till-A.x)+A.y)) {
        (have_one ? ret.till : ret.from) = (x.till-A.x)/(B.x-A.x);
        if (have_one) goto valid;
        have_one = true;
    }
    if (x.IsWithinBool((B.x-A.x)/(B.y-A.y)*(y.from-A.y)+A.x)) {
        (have_one ? ret.till : ret.from) = (y.from-A.y)/(B.y-A.y);
        if (have_one) goto valid;
        have_one = true;
    }
    if (x.IsWithinBool((B.x-A.x)/(B.y-A.y)*(y.till-A.y)+A.x)) {
        (have_one ? ret.till : ret.from) = (y.till-A.y)/(B.y-A.y);
        if (have_one) goto valid;
        _ASSERT(0);
    }
invalid:
    ret.MakeInvalid();
    return ret;
valid:
    if (ret.from > ret.till)
        std::swap(ret.from, ret.till);
    return ret;
}

//////////////////Helper functions

///< Safe cubic root.
inline double curt(double n)
{
    if (n==0) return 0;
    if (n<0) return -pow(-n, 1./3);
    else return pow(n, 1./3);
}

///< Square
inline double sqr(double n)
{
    return n*n;
}

/** Solve quadratic equation.
 *
 * @param [in] m_afCoeff Parameters of the equation. `m_afCoeff[0]` is the constant, `m_afCoeff[2]` is the coeff of `x^2`.
 * @param [out] afRoot Returns the root(s).
 * @returns the number of roots [0..2].
 */
unsigned solve_degree2 (const double m_afCoeff[3], double afRoot[2])
{
    // compute real roots to c[2]x^2+c[1]*x+c[0] = 0
    if (m_afCoeff[2] == 0) {
        //linear
        if (m_afCoeff[1] == 0)
            return -1;
        afRoot[0] = -m_afCoeff[0]/m_afCoeff[1];
        return 1;
    }

    // make polynomial monic
    double afCoeff[2] = { m_afCoeff[0], m_afCoeff[1] };
    if ( m_afCoeff[2] != 1.0f ) {
        double fInv = 1.0f/m_afCoeff[2];
        afCoeff[0] *= fInv;
        afCoeff[1] *= fInv;
    }

    double fDiscr = afCoeff[1]*afCoeff[1]-4.0f*afCoeff[0];
    if ( test_zero(fDiscr) ) {
        afRoot[0] = 0.5f*(-afCoeff[1]);
        return 1;
	}

    if ( fDiscr >= 0.0f ) {
        fDiscr = sqrt(fDiscr);
        afRoot[0] = 0.5f*(-afCoeff[1]-fDiscr);
        afRoot[1] = 0.5f*(-afCoeff[1]+fDiscr);
        return 2;
    }
    return 0;
}

/** Solve qubic equation.
 *
 * @param [in] m_afCoeff Parameters of the equation. `m_afCoeff[0]` is the constant, `m_afCoeff[3]` is the coeff of `x^3`.
 * @param [out] afRoot Returns the root(s).
 * @returns the number of roots [1..3].
 */
unsigned solve_degree3 (const double m_afCoeff[4], double afRoot[3])
{
    // compute real roots to c[3]*x^3+c[2]*x^2+c[1]*x+c[0] = 0
    if (m_afCoeff[3] == 0)
        return solve_degree2(m_afCoeff, afRoot);

    // make polynomial monic
    double afCoeff[3] = { m_afCoeff[0], m_afCoeff[1], m_afCoeff[2] };
    if ( m_afCoeff[3] != 1.0f ) {
        double fInv = 1.0f/m_afCoeff[3];
        afCoeff[0] *= fInv;
        afCoeff[1] *= fInv;
        afCoeff[2] *= fInv;
    }

    // convert to y^3+a*y+b = 0 by x = y-c[2]/3 and
    double fA = (1.0f/3.0f)*(3.0f*afCoeff[1]-afCoeff[2]*afCoeff[2]);
    double fB = (1.0f/27.0f)*(2.0f*afCoeff[2]*afCoeff[2]*afCoeff[2] -
                              9.0f*afCoeff[1]*afCoeff[2]+27.0f*afCoeff[0]);
    double fOffset = (1.0f/3.0f)*afCoeff[2];

    double fDiscr = 0.25f*fB*fB + (1.0f/27.0f)*fA*fA*fA;
    double fHalfB = 0.5f*fB;
    if ( test_zero(fDiscr) ) {    //3 real roots, but at least two are equal
        double fTemp;
        if ( fHalfB >= 0.0f )
            fTemp = -pow(fHalfB, double(1.0/3.0));
        else
            fTemp = pow(-fHalfB, double(1.0/3.0));
        if (test_zero(fTemp)) {
            afRoot[0] = -fOffset;
            return 1;
        }
        afRoot[0] = 2.0f*fTemp-fOffset;
        afRoot[1] = -fTemp-fOffset;
        return 2;
    }

    if ( fDiscr > 0.0f ) { // 1 real, 2 complex roots
        fDiscr = sqrt(fDiscr);
        double fTemp = -fHalfB + fDiscr;
        if ( fTemp >= 0.0f )
            afRoot[0] = pow(fTemp, double(1.0/3.0));
        else
            afRoot[0] = -pow(-fTemp, double(1.0/3.0));
        fTemp = -fHalfB - fDiscr;
        if ( fTemp >= 0.0f )
            afRoot[0] += pow(fTemp, double(1.0/3.0));
        else
            afRoot[0] -= pow(-fTemp, double(1.0/3.0));
        afRoot[0] -= fOffset;
        return 1;
    } else if ( fDiscr < 0.0f ) {  //3 real roots
        double fDist = sqrt(-1.0/3.0*fA);
        double fAngle = (1.0/3.0)*atan2(sqrt(-fDiscr),-fHalfB);
        double fCos = cos(fAngle);
        double fSin = sin(fAngle);
        static const double sqrt3 = sqrt(3.0);
        afRoot[0] = 2.0f*fDist*fCos-fOffset;
        afRoot[1] = -fDist*(fCos+sqrt3*fSin)-fOffset;
        afRoot[2] = -fDist*(fCos-sqrt3*fSin)-fOffset;
        return 3;
    }

    return true;
}

/** Solve quadratic equation.
 *
 * Based on David Eberly's code at
 * <http://svn.berlios.de/wsvn/lwpp/incubator/deeppurple/math/FreeMagic/Source/Core/MgcPolynomial.cpp>
 * @param [in] m_afCoeff Parameters of the equation. `m_afCoeff[0]` is the constant, `m_afCoeff[4]` is the coeff of `x^4`.
 * @param [out] afRoot Returns the root(s).
 * @returns the number of roots [0..4]
 */
unsigned solve_degree4(const double m_afCoeff[5], double afRoot[4])
{
    // compute real roots to c[4]*x^4+c[3]*x^3+c[2]*x^2+c[1]*x+c[0] = 0
    if (m_afCoeff[4] == 0)
        return solve_degree3(m_afCoeff, afRoot);

    // make polynomial monic
    double afCoeff[4] = { m_afCoeff[0], m_afCoeff[1], m_afCoeff[2], m_afCoeff[3] };
    if ( m_afCoeff[4] != 1.0f ) {
        double fInv = 1.0f/m_afCoeff[4];
        afCoeff[0] *= fInv;
        afCoeff[1] *= fInv;
        afCoeff[2] *= fInv;
        afCoeff[3] *= fInv;
    }

    // reduction to resolvent cubic polynomial
    double kResolve[4];
    kResolve[3] = 1.0f;
    kResolve[2] = -afCoeff[2];
    kResolve[1] = afCoeff[3]*afCoeff[1]-4.0f*afCoeff[0];
    kResolve[0] = -afCoeff[3]*afCoeff[3]*afCoeff[0] +
        4.0f*afCoeff[2]*afCoeff[0]-afCoeff[1]*afCoeff[1];
    double afResolveRoot[3];
    /*int iResolveCount = */ solve_degree3(kResolve, afResolveRoot);
    double fY = afResolveRoot[0];

    unsigned num = 0;
    double fDiscr = 0.25f*afCoeff[3]*afCoeff[3]-afCoeff[2]+fY;
    if ( test_zero(fDiscr) ) {
        double fT2 = fY*fY-4.0f*afCoeff[0];
        if ( test_positive(fT2) ) {
            if ( fT2 < 0.0f ) // round to zero
                fT2 = 0.0f;
            fT2 = 2.0f*sqrt(fT2);
            double fT1 = 0.75f*afCoeff[3]*afCoeff[3]-2.0f*afCoeff[2];
            if ( test_positive(fT1+fT2) ) {
                double fD = sqrt(fT1+fT2);
                afRoot[0] = -0.25f*afCoeff[3]+0.5f*fD;
                afRoot[1] = -0.25f*afCoeff[3]-0.5f*fD;
                num = 2;
            }
            if ( test_positive(fT1-fT2) ) {
                double fE = sqrt(fT1-fT2);
                afRoot[num++] = -0.25f*afCoeff[3]+0.5f*fE;
                afRoot[num++] = -0.25f*afCoeff[3]-0.5f*fE;
            }
        }
        return num;
    }

    if ( fDiscr > 0.0f ) {
        double fR = sqrt(fDiscr);
        double fT1 = 0.75f*afCoeff[3]*afCoeff[3]-fR*fR-2.0f*afCoeff[2];
        double fT2 = (4.0f*afCoeff[3]*afCoeff[2]-8.0f*afCoeff[1]-
                      afCoeff[3]*afCoeff[3]*afCoeff[3]) / (4.0f*fR);

        double fTplus = fT1+fT2;
        if ( test_zero(fTplus) ) {
            afRoot[0] = -0.25f*afCoeff[3]+0.5f*fR;
            num = 1;
        } else if ( fTplus >= 0.0f ) {
            double fD = sqrt(fTplus);
            afRoot[0] = -0.25f*afCoeff[3]+0.5f*(fR+fD);
            afRoot[1] = -0.25f*afCoeff[3]+0.5f*(fR-fD);
            num = 2;
        }
        double fTminus = fT1-fT2;
        if ( test_zero(fTminus) )
            fTminus = 0.0f;
        if ( fTminus >= 0.0f ) {
            double fE = sqrt(fTminus);
            afRoot[num++] = -0.25f*afCoeff[3]+0.5f*(fE-fR);
            afRoot[num++] = -0.25f*afCoeff[3]-0.5f*(fE+fR);
        }
        return num;
    }

    //if ( fDiscr < 0.0f )
    return 0;
}

/** Return the arc-length in radians in the clockwise dir from `s` to `e`.
 *
 * The span of the full circle is `2*PI`, what you cannot get as a
 * result from this function (always smaller).
 * If 'e < s' we warp, thus return `2*PI-radianspan(e,s)`.
 */
inline double radianspan(double s, double e)
{
    s = fmod_negative_safe(s, 2*M_PI);
    e = fmod_negative_safe(e, 2*M_PI);
    if (s<=e) return e-s;
    return 2*M_PI - (s-e);
}

/** Helper class for ellipse intersection calculation.
 *
 * The quadratic equation representing the ellipse is
 * `Q(x,y) = a*x^2 + b*x*y + c*y^2 + d*x + e*y + f = 0`
 * where `b*b < 4*a*c` is required for this to represent an ellipse.
 */
struct quadratic_xy_t
{
    double A;  ///< coefficient of `x^2`
    double B;  ///< coefficient of `x*y`
    double C;  ///< coefficient of `y^2`
    double D;  ///< coefficient of `x`
    double E;  ///< coefficient of `y`
    double F;  ///< constant
    quadratic_xy_t() {}
    quadratic_xy_t(const EllipseData &arc); ///< Initialize from an ellipse.
};

quadratic_xy_t::quadratic_xy_t(const EllipseData &arc)
{
    if (!arc.tilted) {
        //fast path
        //equation for non-tilt ellypses is (x-Cx)^2/radius1^2 + (y-Cy)^2/radius2^2 = 1;
        A = 1/sqr(arc.radius1);                                 //*x^2
        B = 0;                                                  //*xy
        C = 1/sqr(arc.radius2);                                 //*y^2
        D = -2*arc.center.x/sqr(arc.radius1);                   //*x
        E = -2*arc.center.y/sqr(arc.radius2);                   //*y
        F = sqr(arc.center.x/arc.radius1) + sqr(arc.center.y/arc.radius2) - 1;
    } else {
        A = sqr(arc.costilt/arc.radius1) + sqr(arc.sintilt/arc.radius2);
        B = 2*arc.costilt*arc.sintilt*(1/sqr(arc.radius1) -  1/sqr(arc.radius2));
        C = sqr(arc.sintilt/arc.radius1) + sqr(arc.costilt/arc.radius2);
        D = -2*arc.costilt/sqr(arc.radius1)*(arc.sintilt*arc.center.y + arc.costilt*arc.center.x) +
            2*arc.sintilt/sqr(arc.radius2)*(arc.costilt*arc.center.y - arc.sintilt*arc.center.x);
        E = -2*arc.sintilt/sqr(arc.radius1)*(arc.sintilt*arc.center.y + arc.costilt*arc.center.x) -
            2*arc.costilt/sqr(arc.radius2)*(arc.costilt*arc.center.y - arc.sintilt*arc.center.x);
        F = (sqr(arc.costilt*arc.center.x) + 2*arc.costilt*arc.sintilt*arc.center.x*arc.center.y + sqr(arc.sintilt*arc.center.y)) / sqr(arc.radius1) +
            (sqr(arc.sintilt*arc.center.x) - 2*arc.costilt*arc.sintilt*arc.center.x*arc.center.y + sqr(arc.costilt*arc.center.y)) / sqr(arc.radius2) -
            1;
    }
}

/** Calculate the Bezout determinant
 */
void get_bezout_determinant (const quadratic_xy_t &one, const quadratic_xy_t & two, double res[5])
{
    // polynomial is constructed as a Bezout determinant
    double fAB = one.A*two.B-two.A*one.B;
    double fAC = one.A*two.C-two.A*one.C;
    double fAD = one.A*two.D-two.A*one.D;
    double fAE = one.A*two.E-two.A*one.E;
    double fAF = one.A*two.F-two.A*one.F;
    double fBC = one.B*two.C-two.B*one.C;
    double fBE = one.B*two.E-two.B*one.E;
    double fBF = one.B*two.F-two.B*one.F;
    double fCD = one.C*two.D-two.C*one.D;
    double fDE = one.D*two.E-two.D*one.E;
    double fDF = one.D*two.F-two.D*one.F;
    double fBFpDE = fBF+fDE;
    double fBEmCD = fBE-fCD;

    res[0] = fAD*fDF-fAF*fAF;
    res[1] = fAB*fDF+fAD*fBFpDE-2.0f*fAE*fAF;
    res[2] = fAB*fBFpDE+fAD*fBEmCD-fAE*fAE-2.0f*fAC*fAF;
    res[3] = fAB*fBEmCD+fAD*fBC-2.0f*fAC*fAE;
    res[4] = fAB*fBC-fAC*fAC;
}

/** Finds a crosspoint of two infinite lines defined by `A`->`B` and `M`->`N`
 */
ELineCrossingType crossing_line_line(const XY &A, const XY &B, const XY &M, const XY &N,  XY &r)
{
	const double perp = (B-A).PerpProduct(N-M);
    if (test_zero(perp)) return LINE_CROSSING_PARALLEL;
    //They are not parallel (and none of them are degenerate)
    const double t = (B-A).PerpProduct(A-M) / perp;
    r = M + (N-M)*t;
    if (!between01_approximate_inclusive(t)) return LINE_CROSSING_OUTSIDE;
    const double s = (N-M).PerpProduct(M-A) / -perp;
    return between01_approximate_inclusive(s) ? LINE_CROSSING_INSIDE : LINE_CROSSING_OUTSIDE;
}

/** Refines the location of a crosspoint of two ellipses. A helper.
 * 
 * This is done using the crosspoints of tangents.
 * @param [in] B The other ellipse we calculate the crosspoints with.
 * @param p The location of the crosspoint, shall be on both ellipses.
 * @returns True if success. False if `p` was not on the ellipses.
 */
bool EllipseData::refine_point(const EllipseData &B, XY &p) const
{
    int max_itr = 32;
    XY p_orig = p;
    while (--max_itr>=0) {
        XY c1 =   conv_to_circle_space(p);
        XY c2 = B.conv_to_circle_space(p);
        const double closeness = fabs(c1.length()-1) + fabs(c2.length()-1);
        if (closeness<1e-30)
            return true;
        const double r1 = circle_space_point2radian_curvy(c1);
        const double r2 = circle_space_point2radian_curvy(c2);
        const XY A1 =   conv_to_real_space(XY(cos(r1)        , sin(r1)        ));
        const XY B1 = B.conv_to_real_space(XY(cos(r2)        , sin(r2)        ));
        //A1 and B1 are points on the ellipses closest to p
        //get rid of p, if it is very far from one of the ellipses
        if (A1.Distance(p_orig) > 4 || B1.Distance(p_orig) > 4)
            return false;
        const XY A2 =   conv_to_real_space(XY(cos(r1)+sin(r1), sin(r1)-cos(r1)));
        const XY B2 = B.conv_to_real_space(XY(cos(r2)+sin(r2), sin(r2)-cos(r2)));
        //Now A1-A2 and B1-B2 are tangents of the two ellipses
        //We operate on the assumption that the intersection of two tangents is closer to the
        //intersection of the ellipses
        XY p_new;
        if (crossing_line_line(A1, A2, B1, B2, p_new) == LINE_CROSSING_PARALLEL)
            p_new = (A1+B1)/2; //no intersection. Lines are parallel
        if ((p-p_new).length_sqr()<1e-30)
            return true; //no improvement, exit
        p = p_new;
    }
    return true;
}

/** Refines the location of a crosspoint of an ellipse and a line. A helper.
 * 
 * This is done using the crosspoints of tangents.
 * @param [in] A A point on the line we calculate the crosspoints with.
 * @param [in] B Another (different) point on the line we calculate the crosspoints with.
 * @param p The location of the crosspoint, shall be on both ellipses.
 * @returns Ture if success. False if `p` was not on the ellipses.
 */
bool EllipseData::refine_point(const XY &A, const XY &B, XY &p) const
{
    int max_itr = 32;
    while (--max_itr>=0) {
        XY c1 =   conv_to_circle_space(p);
        const double closeness = fabs(c1.length()-1);
        if (closeness<1e-30)
            return true;
        const double r1 = circle_space_point2radian_curvy(c1);
        const XY A1 =   conv_to_real_space(XY(cos(r1)        , sin(r1)        ));
        //A1 is a point on the ellipse closest to p
        const XY A2 =   conv_to_real_space(XY(cos(r1)+sin(r1), sin(r1)-cos(r1)));
        //Now A1-A2 is a tangent of the ellipse
        //We operate on the assumption that the intersection of two tangents is closer to the
        //intersection of the ellipses
        XY p_new;
        if (crossing_line_line(A1, A2, A, B, p_new) == LINE_CROSSING_PARALLEL)
            return true; //no intersection. We must be done...
        if ((p-p_new).length_sqr()<1e-30)
            return true; //no improvement, exit
        p = p_new;
    }
    return true;
}

/** Take relevant crosspoints and refine them.
 *
 * This function takes a number of solutions of the intersection equations
 * for y coordinate, and figures out which solutions are actual crosspoints.
 * Then we need to refine crosspoints because the numeric calculations return
 * somewhat limited precision.
 * @param [in] num_y The number of solutions for y.
 * @param [in] y The y coordinates of possible crosspoints.
 * @param [in] B The other ellipse, we calculate the crosspoints with.
 * @param [in] one The equation for our ellipse.
 * @param [in] two The equation for the `B` ellipse.
 * @param [out] p The resulting (actual, refined) crosspoints.
 * @returns The number of actual crosspoints.
 */
int EllipseData::refine_crosspoints(int num_y, double y[], const EllipseData &B,
                                const quadratic_xy_t &one, const quadratic_xy_t &/*two*/, XY p[]) const
{
    // Adjustment for quadratics to allow for relative error testing.
    //const double fNorm_one = one.A*one.A + 2.0f*one.B*one.B + one.C*one.C;
    //const double fNorm_two = two.A*two.A + 2.0f*two.B*two.B + two.C*two.C;

    //go through all solutions of y, find corresponding x
    XY points[8];
    int num_tmp=0;
    for (int i = 0; i < num_y; i++) {
        double ellipse[3], x[2];
        ellipse[0] = one.F+y[i]*(one.E+y[i]*one.C);
        ellipse[1] = one.D+y[i]*one.B;
        ellipse[2] = one.A;
        const int num_x = solve_degree2(ellipse, x);
        //find the two closest point pairs between x_one and x_two
        for (int j = 0; j < num_x; j++) {
            points[num_tmp].x = x[j];
            points[num_tmp].y = y[i];
            if (refine_point(B, points[num_tmp]))
                num_tmp++;
        }
    }
    if (num_tmp==0) return 0;
    // now we have max 8 points, where at most 4 are distinct
    int num = 1;
    p[0] = points[0];
    for (int i=1; i<num_tmp; i++) {
        int j;
        for (j=0; j<num; j++)
            if (p[j].Distance(points[i])<0.1)
                break;
        if (j==num)
            p[num++] = points[i];
    }
    if (num==1 && !IsTilted() && !B.IsTilted()) {
        if (test_equal(center.x, B.center.x)) {
            _ASSERT(test_equal(radius2+B.radius2, fabs(center.y-B.center.y)) ||
                    test_equal(fabs(radius2-B.radius2), fabs(center.y-B.center.y)));
            p[0].x = center.x;
            if (fabs(center.y-radius2-p[0].y) < fabs(center.y+radius2-p[0].y))
                p[0].y = center.y-radius2;
            else
                p[0].y = center.y+radius2;
        } else if (test_equal(center.y, B.center.y)) {
            _ASSERT(test_equal(radius1+B.radius1, fabs(center.x-B.center.x)) ||
                    test_equal(fabs(radius1-B.radius1), fabs(center.x-B.center.x)));
            p[0].y = center.y;
            if (fabs(center.x-radius1-p[0].x) < fabs(center.x+radius1-p[0].x))
                p[0].x = center.x-radius1;
            else
                p[0].x = center.x+radius1;
        }
    }
    return num;
}

/** Transpose the ellipse. Works only if not tilted.
 */
inline void EllipseData::transpose_curvy_non_tilted()
{
    _ASSERT(!tilted);
    std::swap(center.x, center.y);
    std::swap(radius1, radius2);
}

/** Helper that fills in members `extreme_radian` and `extreme` 
 * from `center`, radiuses and `tilt`.
 */
void EllipseData::calculate_extremes()
{
    if (tilted) {
        //this is the radian at which the x coordinate is
        const double ry = atan( (radius2/radius1)*(costilt/sintilt));
        const double rx = atan( (radius2/radius1)/(costilt/sintilt));
        extreme[0] = Radian2Point(extreme_radian[0] = 2.0*M_PI-rx);  //leftmost
        extreme[1] = Radian2Point(extreme_radian[1] =     M_PI-rx);  //rightmost
        extreme[2] = Radian2Point(extreme_radian[2] =     M_PI+ry);  //topmost
        extreme[3] = Radian2Point(extreme_radian[3] =          ry);  //bottommost
    } else {
        extreme[0].x = center.x - radius1;
        extreme[0].y = center.y;
        extreme_radian[0] = M_PI;
        extreme[1].x = center.x + radius1;
        extreme[1].y = center.y;
        extreme_radian[1] = 0;
        extreme[2].y = center.y - radius2;
        extreme[2].x = center.x;
        extreme_radian[2] = M_PI*1.5;
        extreme[3].y = center.y + radius2;
        extreme[3].x = center.x;
        extreme_radian[3] = M_PI*0.5;
    }
}

/** Rotate the ellipse around its center.
 *
 * @param [in] cos The (pre-computed) cosine of `radian`.
 * @param [in] sin The (pre-computed) sine of `radian`.
 * @param [in] radian The amount to rotate (positive if clockwise).
 * @return How much too upgrade radians. This can be an integer multiple of PI/2.
 *         This is returned, since `tilt` is always between [0..PI/2) and if we
 *         rotate by more than this, we re-arrange axes, etc. For example,
 *         if we rotate a non-tilted ellipse by exactly PI/2, the ellipse remains
 *         untilted, just its two radians are swapped. In this case any radian 
 *         values have to be adjusted by PI/2. This adjustment is returned.
 */
double EllipseData::add_to_tilt(double cos, double sin, double radian)
{
    _ASSERT(radian>=0 && radian<=2*M_PI);
	if (radius1==radius2) return radian;
    const double old_tilt = tilted ? tilt : 0;
	if (tilted)
		tilt += radian;
	else
		tilt = radian;
	if (tilt>=2*M_PI) tilt-=2*M_PI;
    if (test_equal(fmod_negative_safe(tilt, M_PI) ,0)) {
		tilted = false;
	} else
        if (test_equal(fmod_negative_safe(tilt, M_PI), M_PI/2)) {
        tilted = false;
        std::swap(radius1, radius2);
    } else if (tilted) { //already tilted and remains so
        double c = costilt;
        costilt = c*cos - sintilt*sin;
        sintilt = c*sin + sintilt*cos;
    } else {
        tilted=true;
        costilt = cos;
        sintilt = sin;
    }
	_ASSERT((tilt>=0 && tilt<2*M_PI) || !tilted);
    const double new_tilt = tilted ? tilt : 0; 
    return fmod_negative_safe(radian-(new_tilt-old_tilt), 2*M_PI); 
}

EllipseData::EllipseData(const XY &c, double radius_x, double radius_y, double tilt_degree) :
center(c), radius1(fabs(radius_x)), radius2(fabs(radius_y)), tilted(false), circumference_cache(-1)
{
    if (radius2 == 0) radius2 = radius1; //circle
    if (radius1 != radius2 && tilt_degree!=0) {
        tilt_degree -= floor(tilt_degree/180)*180;
        if (tilt_degree>=90) {
            tilt_degree -= 90;
            std::swap(radius1, radius2);
        }
        if (tilt_degree) {
            tilt = deg2rad(tilt_degree);
            sintilt = sin(tilt);
            costilt = cos(tilt);
            tilted = true;
        }
    }
	calculate_extremes();
}

/** Calculate the distance of a point from ellipse contour. 
 * 
 * We return a positive distance no matter if the point is inside or outside.
 * Note that we cheat with ellipses, we do not return real distance, just the
 * distance between `p` and the intersection of the `p`->`center` line and the ellipse.
 * @param [in] p The point to seek distance from.
 * @param [out] point Returns a point at the contour of ellipse.
 * @param [out] rad The radiant corresponding to `point`.
 * @returns The distance.
 */
double EllipseData::Distance(const XY &p, XY &point, double &rad) const
{
    if (p.test_equal(center)) {
        rad = (radius2 < radius1) ? M_PI/2 : 0;
        point = Radian2Point(rad);
        return std::min(radius1, radius2);
    }
    if (radius1==radius2) {
        const double cl = center.Distance(p);
        point = center + (p-center)*radius1/cl;
        rad = atan2((point-center).y, (point-center).x);
        return fabs(radius1-cl);
    }
    //We cheat with ellipses, we do not return real distance, just the
    //intersection of the p-center line and the ellipse
    point = conv_to_circle_space(p);
    point.Normalize();
    rad = atan2(point.y, point.x);
    point = conv_to_real_space(point);
    return p.Distance(point);
}

/** Caluclates the distance between an (infinite long) line and the ellipse.
 *
 * If the distance returned is
 * - zero then the line touches the ellipse and `p[0]` return the touchpoint.
 * - negative, the line crosses the ellipse and `p[0]` and `p[1]` returns the two crosspoints.
 * - positive, the line is apart and `p[0]` returns the closest point on the ellipse, 
 *   while `p[1]` on the line.
 * @param [in] start A point on the line.
 * @param [in] end A second point on the line.
 * @param [out] p Returns two relevant points, see above.
 * @returns The distance.
 */
double EllipseData::Distance(const XY &start, const XY &end, XY p[2]) const
{
    int num = CrossingStraight(start, end, p, true);
    switch (num) {
    default: _ASSERT(0);
    case 0: //far apart, p[0] contains closest point, project p[0] to line
        p[1] = p[0].ProjectOntoLine(start, end);
        return p[0].Distance(p[1]);
    case 1: //we touch
        p[1] = p[0];
        return 0; //p[0] is set
    case 2: //we cross
        return -1; //p[0] and p[1] already set
    }
}

/** Translate the ellipse.
 */
void EllipseData::Shift(const XY &xy)
{
    center += xy;
    for (int i=0; i<4; i++)
        extreme[i] += xy;
}

/** Change the size of the ellipse (scale center, as well).
 */
void EllipseData::Scale(double sc)
{
    center *= sc;
    for (int i=0; i<4; i++)
        extreme[i] *= sc;
    if (circumference_cache>=0) circumference_cache *= fabs(sc);
}

/** Roatates ellipse around the origin. 
 *
 * @param [in] cos The (pre-computed) cosine of `radian`.
 * @param [in] sin The (pre-computed) sine of `radian`.
 * @param [in] radian The amount to rotate (positive if clockwise).
 * @return The new tilt
 */
double EllipseData::Rotate(double cos, double sin, double radian)
{
    center.Rotate(cos, sin);
    double ret = add_to_tilt(cos, sin, radian);
    calculate_extremes();
    return ret;
}

/** Roatates ellipse around `c`.
 *
 * @param [in] c The point arount which to rotate.
 * @param [in] cos The (pre-computed) cosine of `radian`.
 * @param [in] sin The (pre-computed) sine of `radian`.
 * @param [in] radian The amount to rotate (positive if clockwise).
 * @return The new tilt 
 */
double EllipseData::RotateAround(const XY&c, double cos, double sin, double radian)
{
    center.RotateAround(c, cos, sin);
    double ret = add_to_tilt(cos, sin, radian);
    calculate_extremes();
    return ret;
}

/** Transposes the ellipse: swaps x & y coordinates of all its points.
 */
void EllipseData::SwapXY()
{
    center.SwapXY();
    if (!IsTilted())
        std::swap(radius1, radius2);
    else {
        tilt = M_PI/2 - tilt; //mirror on 45 degrees
        std::swap(sintilt, costilt);
    }
}

/** Returns the centroid of a sector multiplied by the area of the sector.
 * 
 * @param [in] from The radian from which the sector start clockwise.
 * @param [out] to The radian at which the sector ends. Wraps around if 
 *                      `till` < `from`.
 * @returns The location of the centroid of the sector, multiplied by the sector area.
 */
XY EllipseData::SectorCentroidTimesArea(double from, double to) const
{
    //Here we calculate width a circle sector and approximate it
    //http://en.wikipedia.org/wiki/List_of_centroids
    const double half_arc = fmod_negative_safe(to - from, 2*M_PI)/2;
    if (half_arc>M_PI/2) //below formula valid only for arc<180 deg
        return center*FullArea() - SectorCentroidTimesArea(to, from);
    XY centroid(2./3.*sin(half_arc)/half_arc, 0);
    const double middle = (to+from)/2 + (to>from ? 0 : M_PI);
    centroid.Rotate(cos(middle), sin(middle));
    centroid.x *= radius1;
    centroid.y *= radius2; //here we cheat, not precise for ellipses
    if (tilted)
        centroid.Rotate(costilt, sintilt);
    centroid += center;
    //OK this is the centroid, now multiply by area
    return centroid*SectorArea(from, to);
}


/** Calculates the crosspoint(s) with another ellipse.
 *
 * This is the end-user function to call. Handles all cases, does refining, etc.
 * Returns distinct crosspoints, so that toucing ellipses have just one.
 *
 * @param [in] B The other ellipse.
 * @param [out] r The crosspoint coordinates.
 * @param [out] radian_us The radians of the respective crosspoints in our ellipse.
 * @param [out] radian_b The radians  of the respective crosspoints in B.
 * @returns The number of crosspoints [0..4], or -1 if the two ellipses are identical.
 */
int EllipseData::CrossingEllipse(const EllipseData &B, XY r[], double radian_us[], double radian_b[]) const
{
    //Now this is scary shit. Above there is a suite to solve 4th degree equations, we use those
    //we are interested only in real solutions
    //for ellipses see http://www.geometrictools.com/Documentation/IntersectionOfEllipses.pdf

    //First check if the two ellipses are the same or fully contain one another
    if (center == B.center) { //same center
        if (std::min(radius1, radius2) > std::max(B.radius1, B.radius2) ||
            std::max(radius1, radius2) < std::min(B.radius1, B.radius2))
            return 0; //one is fully in the other (both radiuses smaller than any of the other)
        if (tilted == B.tilted && (!tilted || tilt == B.tilt)) //same tilt
            if ((radius1 == B.radius1 && radius2 == B.radius2) ||
                (radius1 == B.radius2 && radius2 == B.radius1))
                return -1; //equal radiuses - the two ellipses are the same
            if ((radius1<B.radius1 && radius2<B.radius2) ||
                (radius1>B.radius1 && radius2>B.radius2))
                return 0; //one fully in the other
    }

    double y[4];
    int num_y;
    const quadratic_xy_t one(*this), two(B);
    const double TRSHOLD = 1;
    //if two non-tilted ellipses are aliged by an axis bezout determinant becomes
    //numerically instable and gives no roots -> we handle this case separately
    if (!tilted && !B.tilted &&
        (fabs(center.x - B.center.x) < TRSHOLD || fabs(center.y - B.center.y) < TRSHOLD)) {
        if (fabs(center.y - B.center.y) < TRSHOLD && fabs(center.x - B.center.x) >= TRSHOLD ) {
            //In this case we transpose the ellipses call ourself and re-transpose the results
            EllipseData p1(*this), p2(B);
            p1.transpose_curvy_non_tilted();
            p2.transpose_curvy_non_tilted();
            int num = p1.CrossingEllipse(p2, r, radian_us, radian_b);
            for (int i=0; i<num; i++) {
                std::swap(r[i].x, r[i].y);
                radian_us[i] = radian_us[i]<0.5*M_PI ? 0.5*M_PI-radian_us[i] : 2.5*M_PI-radian_us[i];
                radian_b [i] = radian_b [i]<0.5*M_PI ? 0.5*M_PI-radian_b [i] : 2.5*M_PI-radian_b [i];
            }
            return num;
        }
        //in this case multiplying the two ellipse equations by radian1^2 and substracting one from the other
        //we get a simple quadratic equation in y
        double quadratic[3];
        quadratic[2] =                 sqr(radius1/radius2) -              sqr(B.radius1/B.radius2);
        quadratic[1] =     -2*center.y*sqr(radius1/radius2) + 2*B.center.y*sqr(B.radius1/B.radius2);
        quadratic[0] = sqr(  center.y)*sqr(  radius1/  radius2) - sqr(  radius1) +
            -sqr(B.center.y)*sqr(B.radius1/B.radius2) + sqr(B.radius1);
        num_y = solve_degree2(quadratic, y);
        //there are sure to have 2 x values for each y (situation is symmetric to y axis of ellipses)
    } else {
        //This code is based on MgcIntr2DElpElp.cpp written by David Eberly.
        //http://svn.berlios.de/wsvn/lwpp/incubator/deeppurple/math/FreeMagic/Source/Intersection2D/MgcIntr2DElpElp.cpp
        //or http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrEllipse2Ellipse2.cpp
        //we determine the bezout determinant, which is zero only at y coordinate of intersection points
        double bezout[5];
        get_bezout_determinant(one, two, bezout);
        //Solve the Bezout determinant
        num_y = solve_degree4(bezout, y);
    }

    int num = refine_crosspoints(num_y, y, B, one, two, r);

    _ASSERT(num<=4);
    //determine radians
    for (int i=0; i<num; i++) {
        radian_us[i] =   Point2Radian(r[i]);
        radian_b [i] = B.Point2Radian(r[i]);
    }
    return num;
}

/** Calculates `pos` on a straight segment.
 * 
 * @param [in] M Start of the segment.
 * @param [in] N End of the segment.
 * @param [in] p Point to calculate pos for. Assumed to be on the line of `M`->`N`.
 * @returns pos value. [0..1] if p is inside MN, other value if not.
 */
double point2pos_straight(const XY &M, const XY&N, const XY &p)
{
    if (M.test_equal(N)) {
        _ASSERT(M.test_equal(p));
        return 0;
    }
    if (fabs(M.x-N.x) > fabs(M.y-N.y)) {
        double t = (p.x-M.x)/(N.x-M.x);
        if (test_equal(p.y, M.y + (N.y-M.y)*t)) return t;
    } else {
        double t = (p.y-M.y)/(N.y-M.y);
        if (test_equal(p.x, M.x + (N.x-M.x)*t)) return t;
    }
    _ASSERT(0);
    return -1;
}

/** Calculates the crosspoint(s) with an infinite line.
 *
 * @param [in] A One point on the line
 * @param [in] B Another point on the line. Should be different (somewhat apart from) `A`.
 * @param [out] r The crosspoint coordinates.
 * @param [in] want_closest If true, and the line does not cross the ellipse,
               we return the closest point on the line to the ellipse in `r`.
               Setting it to false saves some computations.
 * @returns The number of crosspoints [0..2].
 */
int EllipseData::CrossingStraight(const XY &A, const XY &B, XY *r, bool want_closest) const
{
    const XY M = conv_to_circle_space(A);
    const XY N = conv_to_circle_space(B);

    //See circle intersection with a line specificed by two points
    //http://mathworld.wolfram.com/Circle-LineIntersection.html
    double D = M.PerpProduct(N);
    const XY d = N-M;
    double disc = d.length_sqr() - D*D;
    if (disc<0) {
        //no intersection, check if it almost touches
        const double dist = fabs((N.x-M.x)*(M.y-0) - (M.x-0)*(N.y-M.y))/N.Distance(M);
        if (test_equal(dist,1)) disc=0;
        else if (want_closest) {
            //no crosspoints
            if (test_equal(M.x,N.x)) {
                if (!test_smaller(-1, M.x)) r[0].x = -1;
                else if (!test_smaller(M.x, 1)) r[0].x = 1;
                else {
                    _ASSERT(0);
                }
                r[0].y = 0;
            } else {
                const double m = (M.y-N.y)/(M.x-N.x);
                r[0].x = -sin(atan(m));
                r[0].y = cos(atan(m));  //always positive
                if (M.y-M.x*m < 0) r[0] = -r[0]; //line crosses the Y axis below the unit circle
            }
            r[0] = conv_to_real_space(r[0]);
            //no need to refine, we set r[0] originally exactly to the unit sq
            return 0;
        } else return 0; //did not want closest point to line
    }

    const XY v((d.y<0 ? -d.x : d.x)*sqrt(disc), fabs(d.y)*sqrt(disc));
    const XY f(D*d.y, -D*d.x);
    int num;
    if (disc<1e-20) { //only touch
        r[0] = f/d.length_sqr();
        num = 1;
    } else {
        //the intersect coordinates in unit circle space
        r[0] = (f+v)/d.length_sqr();
        r[1] = (f-v)/d.length_sqr();
        num = 2;
    }
    for (int i=0; i<num; i++) {
        r[i] = conv_to_real_space(r[i]);
        refine_point(A, B, r[i]);
    }
    return num;
}

/** Calculates the crosspoint(s) with an infinite line.
 *
 * This is the end-user function to call. Handles all cases, does refining, etc.
 * Returns distinct crosspoints, so that toucing ellipses have just one.
 *
 * @param [in] A One point on the line
 * @param [in] B Another point on the line. Should be different (somewhat apart from) `A`.
 * @param [out] r The crosspoint coordinates.
 * @param [out] radian_us The radians of the respective crosspoints in our ellipse.
 * @param [out] pos_b The pos values of the respective crosspoints on the `A`->`B` line.
                Zero at `A`, one at `B` and linear in-between or outside them.
 * @returns The number of crosspoints [0..2].
 */
int EllipseData::CrossingStraight(const XY &A, const XY &B,
  	                          XY r[], double radian_us[], double pos_b[]) const
{

    int num = CrossingStraight(A, B, r, false);
    for (int i=0; i<num; i++) {
        radian_us[i] = Point2Radian(r[i]);
        //special case: horizontal line
        if (A.y==B.y) r[i].y = A.y;
        if (A.x==B.x) r[i].x = A.x;
        pos_b[i]  = point2pos_straight(A, B, r[i]);
    }
    return num;
}

/** Calculates the crosspoint of the ellipse with a vertical line.
 *
 * This function is cheaper than CrossingStraight.
 * @param [in] x The x coordinate of the vertical line.
 * @param [out] y The y coordinates of the crosspoints.
 * @param [out] radian The radian values for the respective crosspoints.
 * @returns The number of crosspoints. 1 means a touch.
 */
int EllipseData::CrossingVertical(double x, double y[], double radian[]) const
{
    if (tilted) {
        XY xy[2];
        double dummy[2];
        int num = CrossingStraight(XY(x,0), XY(x, 100), xy, radian, dummy);
        for (int i = 0; i<num; i++)
            y[i] = xy[i].y;
        return num;
    }
    if (x < center.x-radius1 || x > center.x+radius1) return 0; //outside
    y[0] = center.y + radius2*sqrt(1 - sqr((x-center.x)/radius1)); //y coord of one cp
    radian[0] = circle_space_point2radian_curvy(conv_to_circle_space(XY(x,y[0])));
    if (test_equal(y[0], center.y))   //just touch
        return 1;
    y[1] = 2*center.y - y[0];  //the other cp is mirrored (we are !tilted)
    radian[1] = 2*M_PI - radian[0];
    return 2;
}

/** Calculates a point of a tangent.
 * 
 * A *tangent* is a line touching the ellipse. This function takes a
 * radian that specifies a point on the contour of the ellipse. 
 * It then returns a point on the line touching the ellipse in the 
 * said point. The returned point is sufficiently distant from the touchpoint.
 * @param [in] radian The radian at which the tangent is requested.
 * @param [in] next If true the point returned will be in clockwise direction, 
 *                  else counterclockwise.
 * @returns A point on the tangent.
 */
XY EllipseData::Tangent(double radian, bool next) const
{
    const double x = cos(radian);
    const double y = sin(radian);
    //for a point xy on the unit circle to have a point on the
    //forward tangent is: x+y, y-x
    //backward tangent is: x-y, y+x
    if (next)
        return conv_to_real_space(XY(x-y, y+x));
    else
        return conv_to_real_space(XY(x+y, y-x));
}

inline double gk(double h)
{
    double z = 0, x = 1;
    unsigned n = 0;
    while (!test_zero(x)) {
        n++;
        x = h * x * ((n-1.5)/n)*((n-1.5)/n);
        z += x;
    }
    return z+1;
}

inline double cayley(double x) 
{
    double y = log(16/x) - 1;
    double t = x / 4;
    unsigned n = 1;
    double z = 0;
    double u = t * y;
    double v = (n - .5) / n;
    double w = .5 / ((n - .5) * n);
    while (!test_zero(u)) {
        z += u;
        n++;
        t *= x*v;
        v = (n - .5) / n;
        t *= v;
        y -= w;
        w = .5 / ((n - .5) * n);
        y -= w;
        u = t * y;
    }
    return 1 + z;
}


/** Calculates the circumference of the ellipse and stores it in the internal cache.
*/
void EllipseData::CalcCircumferenceEllipse() const
{
    //This is copied from http://www.numericana.com/answer/ellipse.htm#high
    const double a = std::max(radius1, radius2);
    const double b = std::min(radius1, radius2);
    if (b >= 0.28*a) {
        const double h = ((a-b)/(a+b))*((a-b)/(a+b));
        circumference_cache = M_PI*(a+b)*gk(h);
    } else 
        circumference_cache = 4*a*cayley((b/a)*(b/a));
}



/** A helper, calculating the length of the `0`->`to` arc (always positive).
*/
double EllipseData::CircumferenceHelper(double to) const
{
    //Here a computation of incomplete elliptic integral of the second kind is needed
    //See http://www.numericana.com/answer/geometry.htm#ellipticarc
    unsigned num_of_quarters;
    double a, b;
    if (radius1 < radius2) {
        a = radius2;
        b = radius1;
        if (to <= 0.5*M_PI) num_of_quarters = 0;
        else if (to <= 1.5*M_PI) num_of_quarters = 2;
        else num_of_quarters = 4;
    } else {
        a = radius1;
        b = radius2;
        if (to <= M_PI) num_of_quarters = 1;
        else num_of_quarters = 3;
    }
    to -= num_of_quarters*M_PI/2;
    //Now num_of_quarters contains how many quarters of the ellipse we have from 0 to that
    //end of the shorter axis, which is closer to the original "to".
    //Now "to" contains a (-pi/2..+pi/2) range showing a diff from the end of the short axis
    //we need to calculate the length or arc from the end of short axis till "fabs(to)" and add
    //to the quarters if "to" is pos, and substract it if "to" is negative
    //The below formula is by David W. Cantrell from 2002 see in the Internet Archive
    //http://web.archive.org/web/20030225001402/http://mathforum.org/discuss/sci.math/t/469668
    const double L = a * (sin(fabs(to)) + (fabs(to) - sin(fabs(to)))*pow(b/a, 2 - 0.216*fabs(to)*fabs(to)));
    return num_of_quarters*FullCircumference()/4 + (to<0 ? -L : L);
}

/** Expand the ellipse by `gap`.
 * 
 * Done by adding `gap` to the radiuses.
 * @param [in] gap The value to expand with. Negative value results in shrinkage.
 * @returns 1 if OK, 0 if the ellipse degenerated to a section, -1 if it degenerated to a point.
 */
int EllipseData::Expand(double gap)
{
    circumference_cache = -1; //invalidate perimiter cache
    int ret = 1;
    radius1+=gap;
    if (!test_smaller(0,radius1)) ret--;
    radius2+=gap;
    if (!test_smaller(0,radius2)) ret--;
    if (ret>=0) calculate_extremes();
    return ret;
}

double EllipseData::OffsetBelow(const EllipseData&) const
{
    _ASSERT(0);
    return 0;
}

double EllipseData::OffsetBelow(const XY&, const XY&) const
{
    _ASSERT(0);
    return 0;
}

double EllipseData::OffsetAbove(const XY&, const XY&) const
{
    _ASSERT(0);
    return 0;
}

/** Calculates the touchpoint of tangents drawn from a given point.
 * 
 * Given the point `from` draw tangents to the ellipse (two can be drawn)
 * and calculate where these tangents touch the ellipse.
 * In this context the *clockwise tangent* is the one which is traversed from 
 * `from` towards the ellipse touches the ellipse in the clockwise direction.
 * @param [in] from The point from which the tangents are drawn.
 * @param [out] clockwise The point where the clockwise tangent touches the ellipse.
 * @param [out] cclockwise The point where the counterclockwise tangent touches the ellipse.
 * @returns True if success, false if `from` is inside or on the ellipse.
 */
bool EllipseData::TangentFrom(const XY &from, XY &clockwise, XY &cclockwise) const
{
    const XY a = conv_to_circle_space(from);
    const double l = a.length();
    if (!test_smaller(1,l)) return false; //on or inside
    clockwise =  conv_to_real_space(XY(a.y, -a.x)/l);
    cclockwise = conv_to_real_space(XY(-a.y, a.x)/l);
    return true;
}

/** Calculates the touchpoint of tangents drawn to touch two ellipses.
 * 
 * Given the two ellipses, four such tangents can be drawn, here we focus on the two 
 * outer ones, the ones that touch either both ellipses clockwise or both of them
 * counterclockwise, but not mixed.
 * @param [in] from The ellipse from which the tangents are drawn.
 * @param [out] clockwise The points where the clockwise tangent touches our ellipse
 *                        (clockwise[0]) and `from` (clockwise[1]).
 * @param [out] cclockwise The points where the counterclockwise tangent touches our ellipse
 *                         (cclockwise[0]) and `from` (cclockwise[1]).
 * @returns True if success, false if `from` is inside us.
 */
bool EllipseData::TangentFrom(const EllipseData &from, XY clockwise[2], XY cclockwise[2]) const
{
    //TODO: Assume they do not touch
    //XY dummy[4];
    //double dummy2[4];
    //_ASSERT(CrossingEllipse(from, dummy, dummy2, dummy2)==0);
    clockwise[0] = cclockwise[0] = center;
    clockwise[1] = cclockwise[1] = from.center;
    XY old[2];
    do {
        old[0] = clockwise[0];
        old[1] = cclockwise[0];
        XY c, cc;
        if (!from.TangentFrom(clockwise[0], c, cc)) return false;
        clockwise[1] = minmax_clockwise(clockwise[0], clockwise[1], c, true);
        if (!from.TangentFrom(cclockwise[0], c, cc)) return false;
        cclockwise[1] = minmax_clockwise(cclockwise[0], cclockwise[1], cc, false);

        //Now see it back: change dirs
        if (!TangentFrom(clockwise[1], c, cc)) return false;
        clockwise[0] = minmax_clockwise(clockwise[1], clockwise[0], cc, false);
        if (!TangentFrom(cclockwise[1], c, cc)) return false;
        cclockwise[0] = minmax_clockwise(cclockwise[1], cclockwise[0], c, true);
    } while (old[0].DistanceSqr(clockwise[0])>=1 && old[1].DistanceSqr(cclockwise[0])>=1);
    return true;
}




} //namespace
